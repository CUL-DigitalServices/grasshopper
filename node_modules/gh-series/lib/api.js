/**
 * Copyright (c) 2014 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');

var CalendarUtil = require('gh-calendar/lib/util');
var EventsDAO = require('gh-events/lib/internal/dao');
var log = require('gh-core/lib/logger').logger('gh- ');
var Validator = require('gh-core/lib/validator').Validator;

var SeriesDAO = require('./internal/dao');

/**
 * Create a serie
 *
 * @param  {Context}        ctx                         Standard context containing the current user and the current app
 * @param  {Number}         [appId]                     The id of the application that this serie will belong to
 * @param  {String}         displayName                 The name of the serie
 * @param  {String}         description                 The description of the serie
 * @param  {Number}         group                       The id of the group that can manage the event
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                An error object, if any
 * @param  {Serie}          callback.serie              The created serie
 */
var createSerie = module.exports.createSerie = function(ctx, appId, displayName, description, group, callback) {
    appId = appId || req.ctx.app.id;

    // TODO: Validate current user is logged in
    // TODO: Validate app
    // TODO: Validate group
    var validator = new Validator();
    validator.check(displayName, {'code': 400, 'msg': 'A valid displayName must be provided'}).isShortString();
    //validator.check(group, {'code': 400, 'msg': 'A group must be provided'}).isInt();
    if (description) {
        validator.check(description, {'code': 400, 'msg': 'If provided, a description cannot contain more than 1000 characters'}).isMediumString();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    
    SeriesDAO.createSerie(appId, displayName, description, group, callback);
};

/**
 * Update a serie
 *
 * @param  {Context}        ctx                         Standard context containing the current user and the current app
 * @param  {Number}         id                          The id of the serie to update
 * @param  {Object}         update                      The updates to persist. At least one field should be specified
 * @param  {String}         [update.displayName]        The name of the serie
 * @param  {String}         [update.description]        The description of the serie
 * @param  {Number}         [update.group]              The id of the group that can manage the event
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                An error object, if any
 * @param  {Serie}          callback.serie              The updated serie
 */
var updateSerie = module.exports.updateSerie = function(ctx, id, update, callback) {
    // TODO: Validate current user can update
    // TODO: Validate group
    var validator = new Validator();
    validator.check(id, {'code': 400, 'msg': 'A valid serie id must be provided'}).isInt();
    var updatedFields = _.keys(update);
    validator.check(updatedFields, {'code': 400, 'msg': 'At least one of displayName, description or group should be specified'}).notEmpty();
    if (update.displayName) {
        validator.check(update.displayName, {'code': 400, 'msg': 'A valid displayName must be provided'}).isShortString();
    }
    if (update.group) {
        validator.check(update.group, {'code': 400, 'msg': 'A group must be provided'}).isInt();
    }
    if (update.description) {
        validator.check(update.description, {'code': 400, 'msg': 'If provided, a description cannot contain more than 1000 characters'}).isMediumString();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure the serie exist and the current user can access it
    getSerie(ctx, id, function(err, serie) {
        if (err) {
            return callback(err);
        }

        SeriesDAO.updateSerie(serie, update, callback);
    });
};

/**
 * Get a serie
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number}         id                  The id of the serie to retrieve
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {Serie}          callback.serie      The retrieved serie
 */
var getSerie = module.exports.getSerie = function(ctx, id, callback) {
    var validator = new Validator();
    validator.check(id, {'code': 400, 'msg': 'A valid serie id must be provided'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    
    SeriesDAO.getSerie(id, function(err, serie) {
        if (err) {
            return callback(err);
        }

        // Ensure that the serie is either being requested from the app it belongs to
        // or from an authenticated user on the global admin
        if (serie.AppId !== ctx.app.id && (!ctx.user || !ctx.user.isGlobalAdmin())) {
            return callback({'code': 401, 'msg': 'This event cannot be retrieved on this application'});
        }

        return callback(null, serie);
    });
};

/**
 * Delete a serie
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number}         id                  The id of the serie to delete
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 */
var deleteSerie = module.exports.deleteSerie = function(ctx, id, callback) {
    var validator = new Validator();
    validator.check(id, {'code': 400, 'msg': 'A valid serie id must be provided'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    
    getSerie(ctx, id, function(err, serie) {
        if (err) {
            return callback(err);
        }

        // TODO: Authorization
        SeriesDAO.deleteSerie(serie, callback);
    });
};


//////////////////
// Serie events //
//////////////////

/**
 * Add a set of events to a serie
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number}         id                  The id of the serie to add the events to
 * @param  {Number[]}       events              The id(s) of the event(s) to add to the serie
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 */
var addSeriesEvents = module.exports.addSeriesEvents = function(ctx, id, events, callback) {
    var validator = new Validator();
    validator.check(id, {'code': 400, 'msg': 'A valid serie id must be provided'}).isInt();
    validator.check(null, {'code': 400, 'msg': 'The events should be specified as an array of ids'}).isArray(events);
    if (events) {
        validator.check(events.length, {'code': 400, 'msg': 'At least 1 event should be provided'}).min(1);
        _.each(events, function(event) {
            validator.check(event, {'code': 400, 'msg': 'A valid event id must be provided'}).isInt();
        });
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure the serie exists
    getSerie(ctx, id, function(err, serie) {
        if (err) {
            return callback(err);
        }

        // TODO: Authorization

        // Ensure we don't try to add an event twice
        events = _.uniq(events);

        // Ensure the events exist
        EventsDAO.getEvents(events, function(err, events) {
            if (err) {
                return callback(err);
            }

            // Ensure that the events being added to the serie belong to the same application
            var otherAppEvents = _.filter(events, function(event) {
                return (event.AppId !== serie.AppId);
            });
            if (!_.isEmpty(otherAppEvents)) {
                return callback({'code': 400, 'msg': 'Some of the provided events belong to another application'});
            }

            // Ensure we don't try to add an event that's already part of this serie
            SeriesDAO.getSeriesEvents(serie, null, null, 10000, 0, true, function(err, existingEvents) {
                if (err) {
                    return callback(err);
                }

                // Get all the events that are NOT part of the series yet
                var newEvents = _.filter(events, function(event) {
                    return !_.findWhere(existingEvents, {'id': event.id});
                });

                // If there are no new events, we can return early
                if (_.isEmpty(newEvents)) {
                    return callback();
                }

                // Add the events to the serie
                SeriesDAO.addSeriesEvents(serie, events, callback);
            });
        });
    });
};

/**
 * Get the events for a serie
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number}         id                  The id of the serie to retrieve the events for
 * @param  {Number}         [limit]             The number of events that should be retrieved, defaults to 10
 * @param  {Number}         [offset]            The number to start paging from, defaults to 0
 * @param  {Boolean}        [includeUpcoming]   Whether to only include upcoming events. Defaults to `false`
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {Event[]}        callback.events     The events for a series
 */
var getSeriesEvents = module.exports.getSeriesEvents = function(ctx, id, limit, offset, includeUpcoming, callback) {
    limit = limit || 10;
    offset = offset || 0;

    var validator = new Validator();
    validator.check(id, {'code': 400, 'msg': 'A valid serie id must be provided'}).isInt();
    validator.check(limit, {'code': 400, 'msg': 'A valid limit is a positive integer'}).isInt();
    validator.check(limit, {'code': 400, 'msg': 'A valid limit is a positive integer'}).min(1);
    validator.check(offset, {'code': 400, 'msg': 'A valid offset is 0 or any positive integer'}).isInt();
    validator.check(offset, {'code': 400, 'msg': 'A valid offset is 0 or any positive integer'}).min(0);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    return _getSeriesEvents(ctx, id, null, null, limit, offset, includeUpcoming, callback);
};

/**
 * Get the JSON calendar for a series
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number}         id                  The id of the serie to retrieve the calendar for
 * @param  {String}         start               The start date for the calendar
 * @param  {String}         end                 The end date for the calendar
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {Event[]}        callback.events     The calendar for a serie
 */
var getSeriesCalendar = module.exports.getSeriesCalendar = function(ctx, id, start, end, callback) {
    var validator = new Validator();
    validator.check(id, {'code': 400, 'msg': 'A valid serie id must be provided'}).isInt();
    validator.check(start, {'code': 400, 'msg': 'A valid start date must be ISO8601 formatted'}).isDate();
    validator.check(end, {'code': 400, 'msg': 'A valid end date must be ISO8601 formatted'}).isDate();
    validator.check(start, {'code': 400, 'msg': 'The start time must be before the end time'}).isBefore(end);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getSeriesEvents(ctx, id, start, end, -1, 0, true, callback);
};

/**
 * Get the iCal calendar for a series
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number}         id                  The id of the serie to retrieve the calendar for
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {String}         callback.events     The iCal calendar for a serie
 */
var getSeriesCalendarAsICal = module.exports.getSeriesCalendarAsICal = function(ctx, id, callback) {
    _getSeriesEvents(ctx, id, null, null, -1, 0, true, function(err, serie, events) {
        if (err) {
            return callback(err);
        }


        // Convert the events to iCal
        var calendarInfo = _getCalendarInfo(ctx, serie, events);
        var iCal = CalendarUtil.eventsToICal(ctx.app, calendarInfo, events);
        return callback(null, iCal);
    });
};

/**
 * Get the RSS calendar for a series
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number}         id                  The id of the serie to retrieve the calendar for
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {String}         callback.events     The RSS calendar for a serie
 */
var getSeriesCalendarAsRSS = module.exports.getSeriesCalendarAsRSS = function(ctx, id, start, end, callback) {
    getSeriesCalendar(ctx, id, start, end, function(err, serie, events) {
        if (err) {
            return callback(err);
        }

        // Convert the events to RSS
        var calendarInfo = _getCalendarInfo(ctx, serie, events);
        var rss = CalendarUtil.eventsToRSS(ctx.app, calendarInfo, events);
        return callback(null, rss);
    });
};

var _getCalendarInfo = function(ctx, serie, events) {
    // TODO: links
    return serie;
};

/**
 * Internal function that retrieves events for a serie. This function
 * assumes that any validation has happened at an earlier stage.
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number}         id                  The id of the serie to retrieve the events for
 * @param  {Number}         [limit]             The number of events that should be retrieved, defaults to 10
 * @param  {Number}         [offset]            The number to start paging from, defaults to 0
 * @param  {Boolean}        [includeUpcoming]   Whether to only include upcoming events. Defaults to `false`
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {Serie}          callback.serie      The serie the events belong to
 * @param  {Event[]}        callback.events     The events for a series
 * @api private
 */
var _getSeriesEvents = function(ctx, id, start, end, limit, offset, includeUpcoming, callback) {
    // Ensure the serie exists
    getSerie(ctx, id, function(err, serie) {
        if (err) {
            return callback(err);
        }

        // Get the events in this serie
        SeriesDAO.getSeriesEvents(serie, start, end, limit, offset, includeUpcoming, function(err, events) {
            if (err) {
                return callback(err);
            }

            return callback(null, serie, events);
        });
    });
};

/**
 * Remove one or more events from a serie
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number}         id                  The id of the serie to add the events to
 * @param  {Number[]}       events              The id(s) of the event(s) to add to the serie
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 */
var deleteSeriesEvents = module.exports.deleteSeriesEvents = function(ctx, id, events, callback) {
    var validator = new Validator();
    validator.check(id, {'code': 400, 'msg': 'A valid serie id must be provided'}).isInt();
    validator.check(null, {'code': 400, 'msg': 'The events should be specified as an array of ids'}).isArray(events);
    if (events) {
        validator.check(events.length, {'code': 400, 'msg': 'At least 1 event should be provided'}).min(1);
        _.each(events, function(event) {
            validator.check(event, {'code': 400, 'msg': 'A valid event id must be provided'}).isInt();
        });
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure the serie exists
    getSerie(ctx, id, function(err, serie) {
        if (err) {
            return callback(err);
        }

        // TODO: Authorization

        // Ensure that we're removing events from a serie that are under a serie
        SeriesDAO.getSeriesEvents(serie, 10000, 0, true, function(err, existingEvents) {
            if (err) {
                return callback(err);
            }

            // Get the event objects that should be removed from the serie
            var eventsToRemove = _.filter(existingEvents, function(existingEvent) {
                return _.contains(events, existingEvent.id);
            });

            // If there are no events to be removed, we can return early
            if (_.isEmpty(eventsToRemove)) {
                return callback();
            }

            // Remove the events from the serie
            SeriesDAO.removeSeriesEvents(serie, eventsToRemove, callback);
        });
    });
};
