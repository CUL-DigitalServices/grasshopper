
var _ = require('lodash');

/*!
 * All Grasshopper-specific mixins are prefixed with `gh`, followed by a short name that is
 * descriptive to what it should do
 */
_.mixin({

    /**
     * Similar to `_.compact`, except it works on objects instead of just arrays.
     *
     * @param  {Object|Object[]}    obj     The object to compact
     * @return {Object|Object[]}            The resulting object with key/value pairs with falsey pairs omitted
     */
    'ghCompact': function(obj) {
        if (_.isArray(obj)) {
            return _.compact(obj);
        }

        return _.omit(obj, function(val) {
            return (!val);
        });
    },

    /**
     * Extend the source object with only the keys in the `extendWith` object whose value is not
     * `undefined`. This avoids adding unwanted keys when extending with optional properties from
     * another object.
     *
     * For example:
     *
     *  Without lodash:
     *  ```
     *      that.picture = {};
     *       if (opts.smallPictureUri) {
     *           that.picture.smallUri = opts.smallPictureUri;
     *       }
     *       if (opts.mediumPictureUri) {
     *           that.picture.mediumUri = opts.mediumPictureUri;
     *       }
     *       if (opts.largePictureUri) {
     *           that.picture.largeUri = opts.largePictureUri;
     *       }
     *  ```
     *
     *  With `ghExtendDefined`:
     *  ```
     *      that.picture = _.ghExtendDefined({}, {
     *          'smallUri': opts.smallPictureUri,
     *          'mediumUri': opts.mediumPictureUri,
     *          'largeUri': opts.largePictureUri
     *      });
     *  ```
     *
     * @param  {Object}     source      The object to extend. This object will be mutated
     * @param  {Object}     extendWith  The object to merge into the source object
     * @return {Object}                 The resulting `source` object
     */
    'ghExtendDefined': function(source, extendWith) {
        return _.extend(source, _.omit(extendWith, function(value) {
            return (value === undefined);
        }));
    },

    'ghIf': function(predicate, fn/*, [arg0, arg1, ...], callback*/) {
        var fnArgs = _.chain(arguments).toArray().value().slice(2);
        var callback = _.last(fnArgs);
        if (!predicate) {
            return callback();
        }

        return fn.apply(null, fnArgs);
    },

    /**
     * Create an object from a variable list of arguments. This is useful to create objects in one
     * easy method that have keys that aren't static strings. For example:
     *
     *  ```
     *      var myObj = {};
     *      myObj[publicTenant.publicUser.user.id] = 'member';
     *  ```
     *
     *  Can instead be written as:
     *
     *  `var myObj = _.ghObj(publicTenant.publicUser.user.id, 'member');`
     *
     * @param  {String}     key0        The first key to apply to the object
     * @param  {Object}     val0        The value to assign to the first key
     * @param  {String}     key1...     More pairs of keys and values to initialize the object with
     * @return {Object}                 The object with the specified key-value pairs
     */
    'ghObj': function(key0, val0/*, key1, val1, ...]*/) {
        return _.chain(arguments)
            .toArray()
            .chunk(2)
            .zipObject()
            .value();
    },

    'ghOptional': function(opts, defaults) {
        opts = opts || {};
        return _.defaults({}, opts, defaults);
    }
});
