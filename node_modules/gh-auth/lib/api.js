/**
 * Copyright (c) 2014 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var crypto = require('crypto');
var passport = require('passport');
var LocalStrategy = require('passport-local').Strategy;

var AdminsAPI = require('gh-admins');
var AdminsDAO = require('gh-admins/lib/internal/dao');
var Context = require('gh-context').Context;
var GrassHopper = require('gh-core');
var log = require('gh-core/lib/logger').logger('gh-apps');
var UsersAPI = require('gh-users');

/**
 * Initialise the authentication module
 *
 * @param  {Object}         config              The application configuration
 */
var initialise = module.exports.initialise = function(config) {
    // Register the Passport authentication strategies
    registerLocalAuthentication();
    registerSerializeUser(config.cookie.secret);
    registerDeserializeUser(config.cookie.secret);

    // Add the context middleware to the global admin and app Express servers
    // This needs to happen *AFTER* all authentication strategies have been initialized
    GrassHopper.appServer.use(contextMiddleware);
    GrassHopper.globalAdminServer.use(contextMiddleware);
};

/**
 * Register the Passport local authentication strategy
 *
 * @api private
 */
var registerLocalAuthentication = function() {
    passport.use(new LocalStrategy({'passReqToCallback': true}, function(req, username, password, done) {
        // The user is logging in as a global administrator
        if (req.app.isGlobalAdmin) {
            AdminsAPI.validateLoginCredentials(username, password, function(err, globalAdmin) {
                // The provided global administrator credentials are incorrect
                if (err && err.code === 401) {
                    log().info({'err': err, 'app': req.app, 'username': username}, 'Incorrect global administrator credentials have been provided');
                    return done(null, false);
                // A different error occured
                } else if (err) {
                    log().error({'err': err, 'app': req.app, 'username': username}, 'Failed global administrator login attempt');
                    return done(err);
                }

                log().info({'globalAdmin': globalAdmin}, 'Logged in as a global administrator');
                var authInfo = {'user': globalAdmin, 'app': req.app};
                return done(null, authInfo);
            });

        // The user is logging in on a regular app
        } else {
            UsersAPI.validateLoginCredentials(req.app.id, username, password, function(err, user) {
                // The provided user credentials are incorrect
                if (err && err.code === 401) {
                    log().info({'err': err, 'app': req.app, 'username': username}, 'Incorrect user credentials have been provided');
                    return done(null, false);
                // A different error occured
                } else if (err) {
                    log().error({'err': err, 'app': req.app, 'username': username}, 'Failed user login attempt');
                    return done(err);
                }

                log().info({'user': user}, 'Logged in as a user with a local authentication strategy');
                var authInfo = {'user': user, 'app': req.app};
                return done(null, authInfo);
            });
        }
    }));
};

/**
 * Express middleware that will add the Grasshopper `Context` to each request at `req.ctx`.
 * This context object will contain the current app, the currently authenticated user and
 * the user impostering the authenticated user
 *
 * @param  {Request}    req     The Express.js request
 * @param  {Response}   res     The express.js response
 * @param  {Function}   next    Standard callback function
 * @api private
 */
var contextMiddleware = function(req, res, next) {
    var user = null;
    if (req.authInfo && req.authInfo.user) {
        user = req.authInfo.user;
    }

    // TODO: Add imposter

    req.ctx = new Context(req.app, user);
    return next();
};

/**
 * Register the Passport serialize user function. This determines
 * what is stored in the session cookie
 *
 * @param  {String}         cookieSecret        The cookie secret to encrypt the session cookie with
 * @api private
 */
var registerSerializeUser = function(cookieSecret) {
    passport.serializeUser(function(authInfo, callback) {
        // Serialize the user id and whether the user is logged in
        // on the global admin server to the session cookie
        var sessionCookie = {
            'userId': authInfo.user.id,
            'isGlobalAdmin': authInfo.app.isGlobalAdmin
        };

        var encryptedCookie = _encryptCookieData(JSON.stringify(sessionCookie), cookieSecret);
        return callback(null, encryptedCookie);
    });
};

/**
 * Register the Passport deserialize user function. This retrieves
 * the currently logged in user based on the session cookie data.
 *
 * @param  {String}         cookieSecret        The cookie secret used to encrypt the session cookie
 * @api private
 */
var registerDeserializeUser = function(cookieSecret) {
    passport.deserializeUser(function(encryptedCookie, callback) {
        var sessionData = _decryptCookieData(encryptedCookie, cookieSecret);

        try {
            // Parse the cookie data
            sessionData = JSON.parse(sessionData);
        } catch (err) {
            // If parsing failed, the user cookie has malformed session data or has been tampered with.
            // Continue with an empty session
            log().error({'err': err, 'sessionData': sessionData}, 'Failed to deserialize the user cookie');
            sessionData = {};
        }

        // If there is no user in the session, fall back to an anonymous session
        if (!sessionData.userId) {
            return callback(null, false);
        }

        // The user is logged in as a global administrator
        if (sessionData.isGlobalAdmin) {
            AdminsDAO.getGlobalAdmin(sessionData.userId, function(err, globalAdmin) {
                if (err) {
                    log().error({'err': err, 'sessionData': sessionData}, 'Failed to retrieve the global administrator from the session cookie');
                    return callback(err);
                }

                return callback(null, {'user': globalAdmin, 'isGlobalAdmin': sessionData.isGlobalAdmin});
            });

        // The user is logged in on a regular app
        } else {
            UsersAPI.getUser(sessionData.userId, function(err, user) {
                if (err) {
                    log().error({'err': err, 'sessionData': sessionData}, 'Failed to retrieve the logged in user from the session cookie');
                    return callback(err);
                }

                return callback(null, {'user': user, 'isGlobalAdmin': sessionData.isGlobalAdmin});
            });
        }
    });
};

/**
 * Encrypt cookie data to send to the client
 *
 * @param  {String}     cookieData      The cookie data to encrypt
 * @param  {String}     cookieSecret    The secret to encrypt the cookie data with
 * @return {String}                     The encrypted cookie data
 * @api private
 */
var _encryptCookieData = function(cookieData, cookieSecret) {
    var cipher = crypto.createCipher('aes-256-cbc', cookieSecret);
    return cipher.update(cookieData, 'utf8', 'base64') + cipher.final('base64');
};

/**
 * Decrypt cookie data provided by the client
 *
 * @param  {String}     encryptedData   The encrypted cookie data to decrypt
 * @param  {String}     cookieSecret    The secret to decrypt the data with
 * @return {String}                     The decrypted cookie data
 * @api private
 */
var _decryptCookieData = function(encryptedData, cookieSecret) {
    var decipher = crypto.createDecipher('aes-256-cbc', cookieSecret);
    return decipher.update(encryptedData, 'base64', 'utf8') + decipher.final('utf8');
};
