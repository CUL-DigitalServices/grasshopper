
var _ = require('lodash');
var moment = require('moment');
var url = require('url');
var util = require('util');

var AppsAPI = require('gh-apps');
var GrasshopperUtil = require('gh-core/lib/util');
var log = require('gh-core/lib/logger').logger('gh-auth-oauth');
var UsersDAO = require('gh-users/lib/internal/dao');
var Validator = require('gh-core/lib/validator').Validator;

var AuthOauthDAO = require('./oauth/dao');
var AuthOauthUtil = require('./oauth/util');

var createClient = module.exports.createClient = function(ctx, appId, displayName, redirectUri, callback) {
    appId = GrasshopperUtil.getNumberParam(appId);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only administrators can create a client'}).isAdmin(ctx, appId);
    validator.check(appId, {'code': 400, 'msg': 'An integer app id must be specified'}).isInt();
    validator.check(displayName, {'code': 400, 'msg': 'A display name must be specified'}).notEmpty();
    validator.check(displayName.length, {'code': 400, 'msg': 'A display name can be at most 255 characters long'}).isShortString();
    validator.check(redirectUri, {'code': 400, 'msg': 'A valid redirect URI must be specified'}).isUrl();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    AppsAPI.getApp(ctx, appId, function(err, app) {
        if (err) {
            return callback(err);
        }

        return AuthOauthDAO.createClient(app, displayName, AuthOauthUtil.generateClientSecret(), redirectUri, callback);
    });
};

var updateClient = module.exports.updateClient = function(ctx, clientId, fields, callback) {
    clientId = GrasshopperUtil.getNumberParam(clientId);
    fields = fields || {};

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only administrators can update a client'}).isAdmin(ctx, ctx.app.id);
    validator.check(clientId, {'code': 400, 'msg': 'An integer client id must be specified'}).isInt();

    if (fields.displayName) {
        validator.check(fields.displayName.length, {'code': 400, 'msg': 'A display name can be at most 255 characters long'}).isShortString();
    }

    if (fields.redirectUri) {
        validator.check(fields.redirectUri, {'code': 400, 'msg': 'A valid redirect URI must be specified'}).isUrl();
    }

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    AuthOauthDAO.getClient(clientId, function(err, client) {
        if (err) {
            return callback(err);
        }

        validator.check(null, {'code': 401, 'msg': 'Only administrators can update a client'}).isAdmin(ctx, client.AppId);
        if (validator.hasErrors()) {
            return callback(validator.getFirstError());
        }

        return AuthOauthDAO.updateClient(client, _.ghCompact(fields), callback);
    });
};

var disableClient = module.exports.disableClient = function(ctx, clientId, callback) {
    clientId = GrasshopperUtil.getNumberParam(clientId);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only administrators can disable a client'}).isAdmin(ctx, ctx.app.id);
    validator.check(clientId, {'code': 400, 'msg': 'An integer client id must be specified'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    AuthOauthDAO.getClient(clientId, function(err, client) {
        if (err) {
            return callback(err);
        }

        validator.check(null, {'code': 401, 'msg': 'Only administrators can disable a client'}).isAdmin(ctx, client.AppId);
        if (validator.hasErrors()) {
            return callback(validator.getFirstError());
        } else if (client.disabled) {
            return callback({'code': 400, 'msg': 'The specified client is already disabled'});
        }

        return AuthOauthDAO.disableClient(client, callback);
    });
};

var enableClient = module.exports.enableClient = function(ctx, clientId, callback) {
    clientId = GrasshopperUtil.getNumberParam(clientId);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only administrators can enable a client'}).isAdmin(ctx, ctx.app.id);
    validator.check(clientId, {'code': 400, 'msg': 'An integer client id must be specified'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    AuthOauthDAO.getClient(clientId, function(err, client) {
        if (err) {
            return callback(err);
        }

        validator.check(null, {'code': 401, 'msg': 'Only administrators can enable a client'}).isAdmin(ctx, client.AppId);
        if (validator.hasErrors()) {
            return callback(validator.getFirstError());
        } else if (!client.disabled) {
            return callback({'code': 400, 'msg': 'The specified client is already enabled'});
        }

        return AuthOauthDAO.enableClient(client, callback);
    });
};

var regenerateClientSecret = module.exports.regenerateClientSecret = function(ctx, clientId, callback) {
    clientId = GrasshopperUtil.getNumberParam(clientId);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only administrators can regenerate a client secret'}).isAdmin(ctx, ctx.app.id);
    validator.check(clientId, {'code': 400, 'msg': 'An integer client id must be specified'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    AuthOauthDAO.getClient(clientId, function(err, client) {
        if (err) {
            return callback(err);
        }

        validator.check(null, {'code': 401, 'msg': 'Only administrators can regenerate a client secret'}).isAdmin(ctx, client.AppId);
        if (validator.hasErrors()) {
            return callback(validator.getFirstError());
        }

        return AuthOauthDAO.setClientSecret(client, AuthOauthUtil.generateClientSecret(), callback);
    });
};

var getClients = module.exports.getClients = function(ctx, appId, opts, callback) {
    appId = GrasshopperUtil.getNumberParam(appId);
    opts = opts || {};
    opts.limit = GrasshopperUtil.getNumberParam(opts.limit, 25);
    opts.offset = GrasshopperUtil.getNumberParam(opts.offset, 0);

    var validator = new Validator();
    validator.check(appId, {'code': 400, 'msg': 'An integer app id must be provided'}).isInt();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can list clients'}).isLoggedInUser(ctx, appId);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    AppsAPI.getApp(ctx, appId, function(err, app) {
        if (err) {
            return callback(err);
        }

        AuthOauthDAO.getClients(app, opts, function(err, response) {
            if (err) {
                return callback(err);
            }

            // Transform each client according to the current context
            response.rows = _.map(response.rows, _.curry(AuthOauthUtil.transformClient)(ctx));

            return callback(null, response);
        });
    });
};

var getClient = module.exports.getClient = function(ctx, id, callback) {
    id = GrasshopperUtil.getNumberParam(id);

    var validator = new Validator();
    validator.check(id, {'code': 400, 'msg': 'An integer client id must be provided'}).isInt();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can get a client'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the requested client
    AuthOauthDAO.getClient(id, function(err, client) {
        if (err) {
            return callback(err);
        }

        // Ensure the user is authenticated to the client's app
        validator.check(null, {'code': 401, 'msg': 'Only authenticated users can get a client'}).isLoggedInUser(ctx, client.AppId);
        if (validator.hasErrors()) {
            return callback(validator.getFirstError());
        }

        return callback(null, AuthOauthUtil.transformClient(ctx, client));
    });
};

var grantAuthCode = module.exports.grantAuthCode = function(ctx, clientId, forUserId, callback) {
    clientId = GrasshopperUtil.getNumberParam(clientId);
    forUserId = forUserId ? GrasshopperUtil.getNumberParam(forUserId) : forUserId;

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can grant an auth code'}).isLoggedInUser(ctx);
    validator.check(clientId, {'code': 400, 'msg': 'An integer client id must be specified'}).isInt();
    if (forUserId) {
        validator.check(clientId, {'code': 400, 'msg': 'If a user id is specified, it must be an integer'}).isInt();
    }

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    AuthOauthDAO.getClient(clientId, function(err, client) {
        if (err) {
            return callback(err);
        } else if (client.disabled) {
            return callback({'code': 401, 'msg': 'The specified client is disabled'});
        }

        // Determine which user the auth code should be granted for
        var userId = forUserId || ctx.user.id;
        UsersDAO.getUser(userId, function(err, user) {
            if (err) {
                return callback(err);
            } else if (ctx.user.id !== user.id && ctx.user.canAdmin(user.AppId)) {
                return callback({'code': 401, 'msg': 'Only administrators can grant auth codes for other users'});
            }

            // Generate a code that lasts for 10 minutes
            var code = AuthOauthUtil.generateAuthCode();
            var expires = moment().add(10, 'minutes');
            AuthOauthDAO.createAuthCode(client, user, code, expires, function(err, authCode) {
                if (err) {
                    return callback(err);
                }

                // Use the client's configured redirect URI. This isn't entirely correct as we could
                // have received a redirect URI from the request. But currently we don't support
                // multiple registered redirect URIs so this is not necessary
                var parsedRedirectUri = url.parse(client.redirectUri, true);

                // Set `code` parameter to the redirect URI. We clear the `search` parameter because
                // we will format the URI afterward
                parsedRedirectUri.query = _.chain(parsedRedirectUri.query)
                    .ghOptional()
                    .extend({'code': code})
                    .value();
                parsedRedirectUri.search = null;

                log().info({
                    'actorId': ctx.user.id,
                    'clientId': clientId,
                    'forUserId': userId,
                    'expires': expires
                }, 'OAuth Authorization Code has been granted for a user');

                return callback(null, url.format(parsedRedirectUri));
            });
        });
    });
};

var exchangeAuthCode = module.exports.exchangeAuthCode = function(client, code, redirectUri, callback) {
    var validator = new Validator();
    validator.check(code, {'code': 400, 'msg': 'An authorization code must be specified'}).notEmpty();
    validator.check(client, {'code': 400, 'msg': 'An valid client must be specified'}).notEmpty();
    validator.check(redirectUri, {'code': 400, 'msg': 'A valid redirect URI must be specified'}).isUrl();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    } else if (client.disabled) {
        return callback({'code': 401, 'msg': 'The specified client has been disabled'});
    } else if (client.redirectUri !== redirectUri) {
        return callback({'code': 401, 'msg': util.format('The specified redirect uri "%s" does not match the redirect uri configured for the client')});
    }

    AuthOauthDAO.getAuthCodeByCode(code, function(err, authCode) {
        if (err) {
            return callback(err);
        } else if (authCode.OauthClientId !== client.id) {
            return callback({'code': 401, 'msg': 'The provided authorization code does not map to the specified client'});
        } else if (authCode.expires.getTime() <= Date.now()) {
            return callback({'code': 401, 'msg': 'The provided authorization code has expired'});
        }

        UsersDAO.getUser(authCode.UserId, function(err, user) {
            if (err) {
                return callback(err);
            }

            AuthOauthDAO.getAccessTokenByClientAndUser(client, user, function(err, accessToken) {
                if (err && err.code !== 404) {
                    return callback(err);
                } else if (accessToken) {
                    log().info({
                        'clientId': client.id,
                        'redirectUri': redirectUri,
                        'userId': user.id
                    }, 'A client exchanged an authorization code for an access token');
                    return callback(null, accessToken.token);
                }

                var token = AuthOauthUtil.generateAccessToken();
                AuthOauthDAO.createAccessToken(client, user, token, function(err, accessToken) {
                    if (err) {
                        return callback(err);
                    }

                    log().info({
                        'clientId': client.id,
                        'redirectUri': redirectUri,
                        'userId': user.id
                    }, 'A client exchanged an authorization code for an access token');

                    return callback(null, token);
                });
            });
        });
    });
};

var getAccessTokensByUser = module.exports.getAccessTokensByUser = function(ctx, userId, opts, callback) {
    userId = GrasshopperUtil.getNumberParam(userId);
    opts = opts || {};
    opts.limit = GrasshopperUtil.getNumberParam(opts.limit, 25);
    opts.offset = GrasshopperUtil.getNumberParam(opts.offset, 0);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can list access tokens for a user'}).isLoggedInUser(ctx);
    validator.check(userId, {'code': 400, 'msg': 'An integer user id must be specified'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    UsersDAO.getUser(userId, function(err, user) {
        if (err) {
            return callback(err);
        } else if (ctx.user.id !== user.id && !ctx.user.canAdmin(user.AppId)) {
            return callback({'code': 401, 'msg': 'Only administrators or the user themself can list access tokens for a user'});
        }

        AuthOauthDAO.getAccessTokensByUser(user, _.pick(opts, 'limit', 'offset'), function(err, response) {
            if (err) {
                return callback(err);
            }

            // Transform the access token results according to the context
            response.rows = _.map(response.rows, _.curry(AuthOauthUtil.transformAccessToken)(ctx));

            return callback(null, response);
        });
    });
};

var deleteAccessTokenByToken = module.exports.deleteAccessTokenByToken = function(ctx, token, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can delete an access token'}).isLoggedInUser(ctx);
    validator.check(token, {'code': 400, 'msg': 'An access token must be specified'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    AuthOauthDAO.getAccessTokenByToken(token, function(err, accessToken) {
        if (err) {
            return callback(err);
        } else if (!ctx.user.canAdmin(accessToken.OauthClient.AppId) || ctx.user.id !== accessToken.UserId) {
            return callback({'code': 401, 'msg': 'Only administrators or token owners can delete an access token'});
        }

        return AuthOauthDAO.deleteAccessToken(accessToken, callback);
    });
};
