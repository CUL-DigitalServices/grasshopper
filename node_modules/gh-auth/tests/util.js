/**
 * Copyright (c) 2015 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');
var assert = require('assert');
var querystring = require('querystring');
var url = require('url');
var util = require('util');

var AppsTestsUtil = require('gh-apps/tests/util');
var TestsUtil = require('gh-tests/lib/util');
var UsersTestsUtil = require('gh-users/tests/util');

/**
 * Assert a user can log in
 *
 * @param  {RestClient}     client                  The REST client to make the request with
 * @param  {String}         username                The username for the user
 * @param  {String}         password                The password for the user
 * @param  {Function}       callback                Standard callback function
 */
var assertLogin = module.exports.assertLogin = function(client, username, password, callback) {
    client.auth.login(username, password, function(err, body, response) {
        assert.ok(!err);

        // Verify we're logged in
        client.user.getMe(function(err, body, response) {
            assert.ok(!err);
            assert.strictEqual(body.anon, false);
            return callback();
        });
    });
};

/**
 * Assert a user can not log in
 *
 * @param  {RestClient}     client                  The REST client to make the request with
 * @param  {String}         username                The username for the user
 * @param  {String}         password                The password for the user
 * @param  {Function}       callback                Standard callback function
 */
var assertLoginFails = module.exports.assertLoginFails = function(client, username, password, callback) {
    // Get the me feed before trying to log in so we know what our session was like before
    UsersTestsUtil.assertGetMe(client, function(meBefore) {

        // Attempt to log in, ensuring it fails
        client.auth.login(username, password, function(err, body, response) {
            assert.ok(err);
            assert.strictEqual(err.code, 401);

            // Get the me feed again, ensuring our session hasn't changed
            return UsersTestsUtil.assertGetMeEquals(client, meBefore, callback);
        });
    });
};

/**
 * Assert a user can log out
 *
 * @param  {RestClient}     client                  The REST client to make the request with
 * @param  {Function}       callback                Standard callback function
 */
var assertLogout = module.exports.assertLogout = function(client, callback) {
    client.auth.logout(function(err, body, response) {
        assert.ok(!err);

        // Verify we're being redirected to the main page
        assert.ok(_.has(response.headers, 'location'));
        assert.strictEqual(response.headers.location, '/');

        // Verify we're logged out
        client.user.getMe(function(err, body, response) {
            assert.ok(!err);
            assert.strictEqual(body.anon, true);
            return callback();
        });
    });
};

/**
 * Assert that a user can be redirected from the application to the SP
 *
 * @param  {RestClient}     client                  The REST client to make the request with
 * @param  {String}         redirectUrl             The URL where the user should be redirect to once he succesfully authenticates
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.params         The parameters that can be used to initialise the shib flow on the Shibboleth application
 */
var assertShibbolethApplicationRedirect = module.exports.assertShibbolethApplicationRedirect = function(client, redirectUrl, callback) {
    client.auth.shibbolethApplicationRedirect(redirectUrl, function(err, body, response) {
        assert.ok(!err);

        // Verify we're being redirected to our Shibboleth application
        var shibHost = TestsUtil.getConfig().servers.shibbolethSPHost;
        assert.ok(_.has(response.headers, 'location'));
        assert.strictEqual(response.headers.location.indexOf(util.format('https://%s', shibHost)), 0);

        // Get the parameters that need to be sent to the Shibboleth application
        var params = url.parse(response.headers.location, true).query;
        assert.ok(_.has(params, 'app'));
        assert.ok(_.has(params, 'signature'));
        assert.ok(_.has(params, 'expires'));
        return callback(params);
    });
};

/**
 * Assert that a user can not be redirected from the application to the SP
 *
 * @param  {RestClient}     client                  The REST client to make the request with
 * @param  {String}         redirectUrl             The URL where the user should be redirect to once he succesfully authenticates
 * @param  {Number}         code                    The expected HTTP error code
 * @param  {Function}       callback                Standard callback function
 */
var assertShibbolethApplicationRedirectFails = module.exports.assertShibbolethApplicationRedirectFails = function(client, redirectUrl, code, callback) {
    client.auth.shibbolethApplicationRedirect(redirectUrl, function(err, body, response) {
        assert.ok(err);
        assert.strictEqual(err.code, code);
        return callback();
    });
};

/**
 * Assert that a user can be redirected from the SP to the IdP
 *
 * @param  {RestClient}     client                  The REST client to make the request with
 * @param  {Object}         params                  The query string parameters for this endpoint
 * @param  {Number}         params.app              The id of the application on which the user wants to authenticate sign on
 * @param  {String}         params.signature        The signature for the application id
 * @param  {Number}         params.expires          The time in ms since epoch when the signature expires
 * @param  {Function}       callback                Standard callback function
 * @param  {Response}       callback.response       The response object as returned by requestjs
 */
var assertShibbolethSPRedirect = module.exports.assertShibbolethSPRedirect = function(client, params, callback) {
    client.auth.shibbolethSPRedirect(params, function(err, body, response) {
        assert.ok(!err);

        // Verify we're being redirected to mod_shib's /Shibboleth.sso/Login
        assert.ok(_.has(response.headers, 'location'));

        var parsedUrl = url.parse(response.headers.location, true);
        assert.strictEqual(parsedUrl.pathname, '/Shibboleth.sso/Login');
        assert.strictEqual(parsedUrl.query.target, '/api/auth/shibboleth/sp/callback');
        assert.ok(_.has(parsedUrl.query, 'entityID'));
        return callback(response);
    });
};

/**
 * Assert that a user can not be redirected from the SP to the IdP
 *
 * @param  {RestClient}     client                  The REST client to make the request with
 * @param  {Object}         params                  The query string parameters for this endpoint
 * @param  {String}         params.app              The id of the application on which the user wants to authenticate
 * @param  {String}         params.signature        The signature for the application id
 * @param  {Number}         params.expires          The time in ms since epoch when the signature expires
 * @param  {Number}         code                    The expected HTTP error code
 * @param  {Function}       callback                Standard callback function
 */
var assertShibbolethSPRedirectFails = module.exports.assertShibbolethSPRedirectFails = function(client, params, code, callback) {
    client.auth.shibbolethSPRedirect(params, function(err, body, response) {
        assert.ok(err);
        assert.strictEqual(err.code, code);
        return callback();
    });
};

/**
 * Assert the user can be sent back to the Shibboleth application from mod_shib
 *
 * @param  {RestClient}     client                  The REST client to make the request with
 * @param  {Object}         attributes              The attributes that should be sent to the app server
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.params         The parameters that can be used to finalise the authentication process on the application
 */
var assertShibbolethSPCallback = module.exports.assertShibbolethSPCallback = function(client, attributes, callback) {
    client.auth.shibbolethSPCallback(attributes, function(err, body, response) {
        assert.ok(!err);

        // Verify we're being redirected to the user's application
        assert.ok(_.has(response.headers, 'location'));

        // Get the parameters that need to be sent to the user's application
        var params = url.parse(response.headers.location, true).query;
        assert.ok(_.has(params, 'user'));
        assert.ok(_.has(params, 'signature'));
        assert.ok(_.has(params, 'expires'));
        return callback(params);
    });
};

/**
 * Assert the user can not be sent back to the Shibboleth application from mod_shib
 *
 * @param  {RestClient}     client                  The REST client to make the request with
 * @param  {Object}         attributes              The attributes that should be sent to the app server
 * @param  {Number}         code                    The expected HTTP error code
 * @param  {Function}       callback                Standard callback function
 */
var assertShibbolethSPCallbackFails = module.exports.assertShibbolethSPCallbackFails = function(client, attributes, code, callback) {
    client.auth.shibbolethSPCallback(attributes, function(err, body, response) {
        assert.ok(err);
        assert.strictEqual(err.code, code);
        return callback();
    });
};

/**
 * Assert that the user can be sent back to an application
 *
 * @param  {RestClient}     client                  The REST client to make the request with
 * @param  {Object}         params                  The query string parameters for this endpoint
 * @param  {String}         params.userId           The id of the user that will be signing in
 * @param  {String}         params.signature        A signature for the user id
 * @param  {Number}         params.expires          The time in ms since epoch when the signature expires
 * @param  {Function}       callback                Standard callback function
 * @param  {Response}       callback.response       The response object as returned by requestjs
 */
var assertShibbolethApplicationCallback = module.exports.assertShibbolethApplicationCallback = function(client, params, callback) {
    client.auth.shibbolethApplicationCallback(params, function(err, body, response) {
        assert.ok(!err);

        // If we made it here sucesfully, we should have been logged in
        UsersTestsUtil.assertGetMe(client, function(me) {
            assert.ok(!me.anon);
            assert.ok(me.id);
            return callback(response);
        });
    });
};

/**
 * Assert that the user can not be sent back to an application
 *
 * @param  {RestClient}     client                  The REST client to make the request with
 * @param  {Object}         params                  The query string parameters for this endpoint
 * @param  {String}         params.userId           The id of the user that will be signing in
 * @param  {String}         params.signature        A signature for the user id
 * @param  {Number}         params.expires          The time in ms since epoch when the signature expires
 * @param  {Number}         code                    The expected HTTP error code
 * @param  {Function}       callback                Standard callback function
 */
var assertShibbolethApplicationCallbackFails = module.exports.assertShibbolethApplicationCallbackFails = function(client, params, code, callback) {
    client.auth.shibbolethApplicationCallback(params, function(err, body, response) {
        assert.ok(err);
        assert.strictEqual(err.code, code);
        return callback();
    });
};

/**
 * Assert that a user can be authenticated on an application through Shibboleth
 *
 * @param  {App}            app                         The application on which the user should be authentication
 * @param  {String}         [remoteUser]                The value that should be used as the `remote_user` attribute. A random value will be generated if left undefined
 * @param  {Object}         [attributes]                The attributes that mod_shib sends back to the application. Defaults to the empty object
 * @param  {String}         [redirectUrl]               The URL where the user should be redirected to. Defaults to `/`
 * @param  {Function}       callback                    Standard callback function
 * @param  {RestClient}     callback.restClient         The authenticated rest client on the application
 * @param  {String}         callback.remoteUser         The user identifier that was used as the `remote_user` value
 */
var assertShibbolethLogin = module.exports.assertShibbolethLogin = function(app, remoteUser, attributes, redirectUrl, callback) {
    remoteUser = remoteUser || TestsUtil.generateTestUserId();
    redirectUrl = redirectUrl || '/';

    TestsUtil.getAnonymousAppUserClient(app, function(anonymousClient) {

        // 1. Indicate that we want to login in with Shibboleth. The backend will
        // redirect us to the Shibboleth application
        assertShibbolethApplicationRedirect(anonymousClient, redirectUrl, function(params) {

            // 2. Let the Shibboleth application redirect us to mod_shib
            TestsUtil.getShibbolethRestClient(function(shibAppClient) {
                assertShibbolethSPRedirect(shibAppClient, params, function() {

                    // 3. We return from mod_shib
                    var modShibAttributes = _.extend({}, attributes, {
                        // Fake a Shib session
                        'shib-session-id': _.random(100000),

                        // Fake a user
                        'remote_user': remoteUser
                    });
                    assertShibbolethSPCallback(shibAppClient, modShibAttributes, function(params) {

                        // 4. We get sent back to our application and should be logged in
                        assertShibbolethApplicationCallback(anonymousClient, params, function(response) {

                            // Verify the user was sent to the correct redirect url
                            assert.strictEqual(response.headers.location, redirectUrl);

                            // Pass the (now authenticated) rest client back to the caller
                            return callback(anonymousClient, remoteUser);
                        });
                    });
                });
            });
        });
    });
};

var assertOauthClient = module.exports.assertOauthClient = TestsUtil.createAssertionFunction();

var assertGetAllOauthClients = module.exports.assertGetAllOauthClients = function(client, opts, callback) {
    opts = opts || {};

    // Get the first page to get a count
    assertGetOauthClients(client, _.extend({}, opts, {'limit': 1}), function(firstResponse) {

        // One request to get them all
        assertGetOauthClients(client, _.extend({}, opts, {'limit': firstResponse.count}), function(secondResponse) {
            assert.strictEqual(secondResponse.count, firstResponse.count);
            assert.strictEqual(secondResponse.count, secondResponse.rows.length);
            return callback(secondResponse.rows);
        });
    });
};

var assertGetOauthClients = module.exports.assertGetOauthClients = function(client, opts, callback) {
    opts = opts || {};

    // Get the expected app
    UsersTestsUtil.assertGetMe(client, function(me) {
        var expectedAppId = opts.appId || me.app.id;

        client.auth.getOauthClients(opts, function(err, response) {
            assert.ok(!err);
            assert.ok(response.count >= response.rows.length);

            _.each(response.rows, function(oauthClient) {
                assertOauthClient(oauthClient, {
                    'match': {
                        'AppId': expectedAppId
                    },
                    'validate': {
                        'id': _.isNumber,
                        'displayName': _.isString
                    }
                });
            });

            return callback(response);
        });
    });
};

var assertGetOauthClient = module.exports.assertGetOauthClient = function(client, id, callback) {
    client.auth.getOauthClient(id, function(err, oauthClient) {
        assert.ok(!err);
        assertOauthClient(oauthClient, {
            'validate': {
                'id': _.isNumber,
                'displayName': _.isString,
                'AppId': _.isNumber
            }
        });

        return callback(oauthClient);
    });
};

var assertCreateOauthClient = module.exports.assertCreateOauthClient = function(client, displayName, redirectUri, opts, callback) {
    opts = opts || {};

    // Get the expected app
    UsersTestsUtil.assertGetMe(client, function(me) {
        var expectedAppId = opts.appId || me.app.id;

        // Create the client
        client.auth.createOauthClient(displayName, redirectUri, opts, function(err, oauthClientCreated) {
            assert.ok(!err);
            assertOauthClient(oauthClientCreated, {
                'match': {
                    'AppId': expectedAppId,
                    'displayName': displayName,
                    'redirectUri': redirectUri
                },
                'validate': {
                    'id': _.isNumber,
                    'secret': _.isString,
                    'disabled': _.isNull
                }
            });

            // Ensure the oauth client is available in the global list of clients for the app
            assertGetOauthClient(client, oauthClientCreated.id, function(oauthClientAfterCreate) {
                assertOauthClient(oauthClientAfterCreate, {'equals': oauthClientCreated});
                return callback(oauthClientAfterCreate);
            });
        });
    });
};

var assertUpdateOauthClient = module.exports.assertUpdateOauthClient = function(client, id, fields, callback) {
    // Update the client, ensuring the response matches the updated values
    client.auth.updateOauthClient(id, fields, function(err, oauthClientUpdated) {
        assert.ok(!err);
        assertOauthClient(oauthClientUpdated, {
            'match': fields,
            'validate': {
                'id': _.isNumber,
                'secret': _.isString,
                'disabled': _.isNull
            }
        });

        // Get the client, ensuring it matches the new values
        assertGetOauthClient(client, id, function(oauthClientAfterUpdate) {
            assertOauthClient(oauthClientAfterUpdate, {'equals': oauthClientUpdated});
            return callback(oauthClientAfterUpdate);
        });
    });
};

var assertDisableOauthClient = module.exports.assertDisableOauthClient = function(client, id, callback) {
    assertGetOauthClient(client, id, function(oauthClientBeforeDisable) {
        var millisBeforeDisable = Date.now();
        client.auth.disableOauthClient(id, function(err, oauthClientDisabled) {
            assert.ok(!err);
            assertOauthClient(oauthClientDisabled, {
                // Ensure only the disabled and updatedAt fields have changed
                'equals': _.extend({}, oauthClientBeforeDisable, _.pick(oauthClientDisabled, 'disabled', 'updatedAt')),
                'validate': {
                    // Ensure the disabled timestamp falls inside the small range of time in which it was disabled
                    'disabled': function(timestampStr) {
                        if (!_.isString(timestampStr) || _.isEmpty(timestampStr)) {
                            assert.fail('Disabled timestamp was not a non-empty string');
                        }

                        var timestampDate = new Date(timestampStr);
                        return (timestampDate.getTime() >= millisBeforeDisable && timestampDate.getTime() <= Date.now());
                    }
                }
            });

            // Ensure the client changes are persistent
            assertGetOauthClient(client, id, function(oauthClientAfterDisable) {
                assertOauthClient(oauthClientDisabled, {'equals': oauthClientAfterDisable});
                return callback(oauthClientAfterDisable);
            });
        });
    });
};

var assertEnableOauthClient = module.exports.assertEnableOauthClient = function(client, id, callback) {
    assertGetOauthClient(client, id, function(oauthClientBeforeEnable) {
        client.auth.enableOauthClient(id, function(err, oauthClientEnabled) {
            assert.ok(!err);
            assertOauthClient(oauthClientEnabled, {
                // Ensure only the disabled and updatedAt fields have changed
                'equals': _.extend({}, oauthClientBeforeEnable, _.pick(oauthClientEnabled, 'disabled', 'updatedAt')),
                'validate': {
                    'disabled': _.isNull
                }
            });

            // Ensure the client changes are persistent
            assertGetOauthClient(client, id, function(oauthClientAfterEnable) {
                assertOauthClient(oauthClientEnabled, {'equals': oauthClientAfterEnable});
                return callback(oauthClientAfterEnable);
            });
        });
    });
};

var assertRegenerateOauthClientSecret = module.exports.assertRegenerateOauthClientSecret = function(client, id, callback) {
    assertGetOauthClient(client, id, function(oauthClientBeforeRegenerate) {
        client.auth.regenerateOauthClientSecret(id, function(err, oauthClientRegenerated) {
            assert.ok(!err);
            assertOauthClient(oauthClientRegenerated, {
                // Ensure only the secret and updatedAt fields have changed
                'equals': _.extend({}, oauthClientBeforeRegenerate, _.pick(oauthClientRegenerated, 'secret', 'updatedAt')),
                'validate': {
                    'secret': function(actualSecret) {
                        // Ensure the secret changed
                        return (actualSecret !== oauthClientBeforeRegenerate.secret);
                    }
                }
            });

            // Ensure the client changes are persistent
            assertGetOauthClient(client, id, function(oauthClientAfterRegenerate) {
                assertOauthClient(oauthClientRegenerated, {'equals': oauthClientAfterRegenerate});
                return callback(oauthClientAfterRegenerate);
            });
        });
    });
};

var assertGrantOauthAuthCode = module.exports.assertGrantOauthAuthCode = function(client, oauthClientId, opts, callback) {
    assertGetOauthClient(client, oauthClientId, function(oauthClient) {
        client.auth.grantOauthAuthCode(oauthClientId, opts, function(err, body, response) {
            assert.ok(!err);

            var actualParsedRedirectUri = url.parse(response.headers.location, true);
            var expectedParsedRedirectUri = url.parse(oauthClient.redirectUri, true);

            // Ensure we got a code
            assert.ok(_.isObject(actualParsedRedirectUri.query));
            assert.ok(_.isString(actualParsedRedirectUri.query.code));

            // Ensure that aside from the code being added, the redirect URI is the same as that of
            // the client
            assert.strictEqual(actualParsedRedirectUri.protocol, expectedParsedRedirectUri.protocol);
            assert.strictEqual(actualParsedRedirectUri.hostname, expectedParsedRedirectUri.hostname);
            assert.strictEqual(actualParsedRedirectUri.pathname, expectedParsedRedirectUri.pathname);
            assert.deepEqual(actualParsedRedirectUri.query, _.extend({}, expectedParsedRedirectUri.query, {'code': actualParsedRedirectUri.query.code}));

            return callback(actualParsedRedirectUri.query.code, response.headers.location);
        });
    });
};

var assertGetAllOauthAccessTokensByUser = module.exports.assertGetAllOauthAccessTokensByUser = function(client, userId, callback) {
    assertGetOauthAccessTokensByUser(client, userId, {'limit': 1}, function(firstResponse) {
        assertGetOauthAccessTokensByUser(client, userId, {'limit': firstResponse.count}, function(secondResponse) {
            assert.strictEqual(secondResponse.count, firstResponse.count);
            assert.strictEqual(secondResponse.count, secondResponse.rows.length);
            return callback(secondResponse);
        });
    });
};

var assertGetOauthAccessTokensByUser = module.exports.assertGetOauthAccessTokensByUser = function(client, userId, opts, callback) {
    client.auth.getOauthAccessTokensByUser(userId, opts, function(err, response) {
        assert.ok(!err);
        assert.ok(_.isNumber(response.count));
        assert.ok(_.isArray(response.rows));
        assert.ok(response.count >= response.rows.length);

        // TODO: Generic access token assertions

        return callback(response);
    });
};

var assertExchangeOauthAuthCode = module.exports.assertExchangeOauthAuthCode = function(client, oauthClientId, oauthClientSecret, code, redirectUri, opts, callback) {
    TestsUtil.getGlobalAdminRestClient(function(globalAdminClient) {

        // Get the target app and oauth client
        assertGetOauthClient(client, oauthClientId, function(oauthClient) {
            AppsTestsUtil.assertGetApp(globalAdminClient, oauthClient.AppId, null, function(app) {

                // Get the access token
                client.auth.exchangeOauthAuthCode(oauthClientId, oauthClientSecret, code, redirectUri, opts, function(err, response) {
                    assert.ok(!err);
                    assert.ok(response);
                    assert.strictEqual(response.token_type, 'Bearer');

                    var token = response.access_token;
                    assert.ok(_.isString(token));

                    // Get a client that is wired to make requests with the access token
                    TestsUtil.getOauthAppUserClient(app, token, function(bearerClient) {
                        return callback(bearerClient, token);
                    });
                });
            });
        });
    });
};
