/**
 * Copyright (c) 2014 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');
var assert = require('assert');

var ConfigTestsUtil = require('gh-config/tests/util');
var TestsUtil = require('gh-tests/lib/util');
var UsersTestsUtil = require('gh-users/tests/util');

var StatsdAPI = require('gh-statsd');
var StatsdTestsUtil = require('./util');

describe('Statsd', function() {

    /**
     * Disable the statsd integration when all tests are over
     */
    after(function() {
        StatsdAPI.init({
            'enabled': false,
        });
    });

    /**
     * Test that verifies that requests are tracked with statsd
     */
    it('verify requests are tracked with statsd', function(callback) {
        // Mock a statsd server
        var socket = StatsdTestsUtil.mockStatsdServer(8000);

        // Configure the statsd module so it sends metrics to the mocked statsd server
        StatsdAPI.init({
            'enabled': true,
            'host': '127.0.0.1',
            'port': 8000,
            'scope': 'gh'
        });

        // Keep track of all the messages
        var messages = {};
        socket.on('message', function(msg, rinfo) {
            // Convert the buffer to a string and parse the statsd command
            // A typical buffer might look like:
            //     gh.http.200.count:1|c
            var data = msg.toString().split(':');

            messages[data[0]] = messages[data[0]] || [];
            messages[data[0]].push(data[1]);
        });

        TestsUtil.generateTestUsers(global.tests.apps.cam2013, 1, false, function(simon) {

            // Sending data to statsd happens after the request ends. We use a setTimeout
            // because we don't want to overload the telemetry tracking more than needed.
            setTimeout(function() {

                // Assert that each message was prefixed with the `scope` parameter
                _.each(messages, function(values, metric) {
                    assert.strictEqual(metric.split('.')[0], 'gh');
                });

                // Assert the create users call was tracked
                assert.ok(_.isArray(messages['gh.http.POST.api_users.time']));
                assert.ok(_.isArray(messages['gh.http.POST.api_users.201.count']));

                // Assert we keep track of responses in general as well
                assert.ok(_.isArray(messages['gh.http.201.count']));

                socket.close();
                return callback();
            }, 500);
        });
    });

    /**
     * Test that verifies that applications can specify their own statsd instance
     */
    it('verify applications can specify their own statsd instance', function(callback) {
        // Mock two statsd servers
        var socket1 = StatsdTestsUtil.mockStatsdServer(8000);
        var socket2 = StatsdTestsUtil.mockStatsdServer(8001);

        // Configure the statsd module so it sends metrics to the mocked statsd server
        StatsdAPI.init({
            'enabled': true,
            'host': '127.0.0.1',
            'port': 8000,
            'scope': 'gh'
        });

        // Keep track of all the messages
        var messages1 = {};
        socket1.on('message', function(msg, rinfo) {
            // Convert the buffer to a string and parse the statsd command
            // A typical buffer might look like:
            //     gh.http.200.count:1|c
            var data = msg.toString().split(':');

            messages1[data[0]] = messages1[data[0]] || [];
            messages1[data[0]].push(data[1]);
        });
        var messages2 = {};
        socket2.on('message', function(msg, rinfo) {
            // Convert the buffer to a string and parse the statsd command
            // A typical buffer might look like:
            //     gh.http.200.count:1|c
            var data = msg.toString().split(':');

            messages2[data[0]] = messages2[data[0]] || [];
            messages2[data[0]].push(data[1]);
        });

        // Generate an application with a custom statsd instance
        TestsUtil.generateTestTenant(1, function(tenant, app) {

            // Configure the application with a custom statsd server
            TestsUtil.getGlobalAdminRestClient(function(globalAdminClient) {
                var update = {'statsd': '127.0.0.1:8001:custom'};
                ConfigTestsUtil.assertUpdateConfig(globalAdminClient, app.id, update, function() {

                    TestsUtil.generateTestUsers(app, 1, false, function(simon) {

                        // Perform a me request that can be tracked
                        UsersTestsUtil.assertGetMe(simon.client, function(me) {

                            // Sending data to statsd happens after the request ends. We use a setTimeout
                            // because we don't want to overload the telemetry tracking more than needed.
                            setTimeout(function() {

                                /*!
                                 * Assert that a set of messages were tracked
                                 *
                                 * @param  {Object}     messages    All the messages
                                 * @param  {String}     prefix      The statsd scope prefix
                                 */
                                var assertMessages = function(messages, prefix) {
                                    // Assert that each message was prefixed with the `scope` parameter
                                    _.each(messages, function(values, metric) {
                                        assert.strictEqual(metric.split('.')[0], prefix);
                                    });

                                    // Assert the create users call was tracked
                                    assert.ok(_.isArray(messages[prefix + '.http.GET.api_me.time']));
                                    assert.ok(_.isArray(messages[prefix + '.http.GET.api_me.200.count']));

                                    // Assert we keep track of responses in general as well
                                    assert.ok(_.isArray(messages[prefix + '.http.200.count']));
                                };

                                // Assert we've sent messages to the general statsd server
                                assertMessages(messages1, 'gh');

                                // Assert we've also sent messages to the app specific statsd server
                                assertMessages(messages2, 'custom');

                                socket1.close();
                                socket2.close();
                                return callback();
                            }, 500);
                        });
                    });
                });
            });
        });
    });
});
