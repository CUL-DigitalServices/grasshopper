/**
 * Copyright (c) 2014 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var Sequelize = require('sequelize');

var DB = require('gh-core/lib/db');
var log = require('gh-core/lib/logger').logger('gh-users');

/**
 * Create a new user object
 * @param  {Context}    ctx                                 The current execution context containing the user and application
 * @param  {String}     tenantId                            The id of the tenant on which to create the user account
 * @param  {Object}     credentials                         Specifies the authentication strategy that the users wants to use and the credentials for it
 * @param  {String}     credentials.strategy                One of `local` or `shibboleth`
 * @param  {String}     [credentials.username]              The `username` the user logs in with when the `local` strategy was chosen
 * @param  {String}     [credentials.password]              The `password` the user logs in with when the `local` strategy was chosen
 * @param  {String}     [credentials.shibbolethId]          The Shibboleth entity id for the user when the `shibboleth` strategy was chosen
 * @param  {Object}     userProfile                         The user profile parameters for the new user account
 * @param  {String}     userProfile.displayName             The display name of the new user
 * @param  {String}     userProfile.email                   The email address of the new user
 * @param  {String}     [userProfile.emailPreference]       The email preference of the new user
 * @param  {Function}   callback                            Standard callback function
 * @param  {Object}     callback.err                        An error that occurred, if any
 * @param  {User}       callback.user                       A user object
 */
var createUser = module.exports.createUser = function(ctx, tenantId, credentials, userProfile, callback) {
    userProfile = userProfile || {};
    userProfile.emailPreference = userProfile.emailPreference || 'immediate';
    // Todo: Parameter validation
    // Todo: Tenant/app validation
    
    if (!credentials || !credentials.type) {
        return callback({'code': 400, 'msg': 'Missing credentials type'});
    }

    // Ensure that the user doesn't already exist
    _ensureUnique(ctx, tenantId, credentials, userProfile, function(err, exists) {
        if (err) {
            return callback(err);
        } else if (exists) {
            return callback({'code': 400, 'msg': 'The provided credentials already exist'});
        }

        var opts = {
            'TenantId': tenantId,
            'displayName': userProfile.displayName,
            'email': userProfile.email,
            'emailPreference': userProfile.emailPreference,
            'authenticationStrategy': credentials.type
        };
        if (credentials.type === 'local') {
            opts.username = credentials.username;
            // Salt and hash the password when persisting it
            opts.password = DB.User.hash(credentials.password);
        } else if (credentials.type === 'shibboleth') {
            opts.shibbolethId = credentials.shibbolethId;
        }

        // Persist the user account
        DB.User.create(opts).complete(function(err, user) {
            if (err) {
                log().error({'err': err}, 'Failed to persist user');
                return callback({'code': 500, 'msg': err.message});
            }

            log().debug({'user': user}, 'Created a user account');
            return callback(null, user);
        });
    });
};

var _ensureUnique = function(ctx, tenantId, credentials, userProfile, callback) {
    var credentialFilter = null;
    if (credentials.type === 'local') {
        // The username has to be unique within the tenant
        credentialFilter = Sequelize.and({'username': credentials.username}, {'TenantId': tenantId});
    } else if (credentials.type === 'shibboleth') {
        // The Shibboleth entity ID has to be unique within the tenant
        credentialFilter = Sequelize.and({'shibbolethId': credentials.shibbolethId}, {'TenantId': tenantId});
    }

    // The email has to be globally unique
    var emailFilter = {'email': userProfile.email};

    // If either of the filters return a user, we can't allow the user creation to proceed
    var where = Sequelize.or(credentialFilter, emailFilter);
    DB.User.find({'where': where}).complete(function(err, user) {
        if (err) {
            log().error({'err': err}, 'Unable to lookup a user by username or email address');
            return callback({'code': 500, 'msg': 'Unable to lookup a user by username or email address'});
        }

        var exists = (user !== null);
        return callback(null, exists);
    });
};
