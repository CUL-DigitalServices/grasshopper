/**
 * Copyright (c) 2014 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var Sequelize = require('sequelize');

var DB = require('gh-core/lib/db');
var log = require('gh-core/lib/logger').logger('gh-users');

/**
 * Create a new user object
 *
 * @param  {Context}    ctx                                 The current execution context containing the user and application
 * @param  {Number}     tenantId                            The id of the tenant to which the user should be added
 * @param  {Number[]}   apps                                The id(s) of the app(s) to which the user should be added
 * @param  {Object}     userProfile                         The user profile parameters for the user
 * @param  {String}     userProfile.displayName             The name of the user
 * @param  {String}     userProfile.email                   The email address for the user
 * @param  {Object}     credentials                         Specifies the authentication strategy that the users wants to use and the credentials for it
 * @param  {String}     credentials.strategy                The authentication strategy for the user. One of `local` or `shibboleth`
 * @param  {String}     [credentials.password]              The password with which the user will authenticate. Only required when using the local authentiation strategy
 * @param  {String}     [credentials.shibbolethId]          The unique shibboleth id for the user. Only required when using the Shibboleth authentication strategy
 * @param  {Function}   callback                            Standard callback function
 * @param  {Object}     callback.err                        An error that occurred, if any
 * @param  {User}       callback.user                       The created user
 */
var createUser = module.exports.createUser = function(ctx, tenantId, apps, userProfile, credentials, callback) {
    //userProfile = userProfile || {};
    //userProfile.emailPreference = userProfile.emailPreference || 'immediate';
    // Todo: Parameter validation
    // Todo: Tenant/app validation

    // TODO: tenantId validation
    // TODO: displayName validation
    // TODO: email validation
    // TODO: strategy validation

    // TODO: validate that tenant exists
    // TODO: validate that all apps exist
    // TODO: validate that user with credentials doesn't already exist

    // TODO: create tenant user
    // TODO: create app users

    // Ensure that the user doesn't already exist
    //_getUser(ctx, tenantId, credentials, userProfile, function(err, user) {
    //    if (err) {
    //        return callback(err);
    //    } else if (user) {
    //        return callback({'code': 400, 'msg': 'The provided credentials already exist'});
    //    }

    //    _createUser(ctx, tenantId, credentials, userProfile, callback);
    //});
};

/**
 * Create a new user object. This function will not perform any validation
 *
 * @see createUser
 *
var _createUser = function(ctx, tenantId, credentials, userProfile, callback) {
    var opts = {
        'TenantId': tenantId,
        'displayName': userProfile.displayName,
        'email': userProfile.email,
        'emailPreference': userProfile.emailPreference,
        'authenticationStrategy': credentials.type
    };
    if (credentials.type === 'local') {
        opts.username = credentials.username;
        // Salt and hash the password when persisting it
        opts.password = DB.User.hash(credentials.password);
    } else if (credentials.type === 'shibboleth') {
        opts.shibbolethId = credentials.shibbolethId;
    }

    // Persist the user account
    DB.User.create(opts).done(function(err, user) {
        if (err) {
            log().error({'err': err}, 'Failed to persist user');
            return callback({'code': 500, 'msg': err.message});
        }

        log().debug({'user': user}, 'Created a user account');
        return callback(null, user);
    });
};

/**
 * Retrieves or creates a user object. If the user object could not
 * be found for the provided credentials and email, it will be created
 *
 * @see createUser
 *
var getOrCreateUser = module.exports.getOrCreateUser = function(ctx, tenantId, credentials, userProfile, callback) {
    _getUser(ctx, tenantId, credentials, userProfile, function(err, user) {
        if (err) {
            return callback(err);
        } else if (user) {
            return callback(null, user);
        } else {
            return createUser(ctx, tenantId, credentials, userProfile, callback);
        }
    });
};

/**
 * Retrieve a user object. This function wil not perform any validation
 *
 * @see createUser
 *
var _getUser = function(ctx, tenantId, credentials, userProfile, callback) {
    var credentialFilter = null;
    if (credentials.type === 'local') {
        // The username has to be unique within the tenant
        credentialFilter = Sequelize.and({'username': credentials.username}, {'TenantId': tenantId});
    } else if (credentials.type === 'shibboleth') {
        // The Shibboleth entity ID has to be unique within the tenant
        credentialFilter = Sequelize.and({'shibbolethId': credentials.shibbolethId}, {'TenantId': tenantId});
    }

    // The email has to be globally unique
    var emailFilter = {'email': userProfile.email};

    // If either of the filters return a user, we can't allow the user creation to proceed
    var where = Sequelize.or(credentialFilter, emailFilter);
    DB.User.find({'where': where}).done(function(err, user) {
        if (err) {
            log().error({'err': err}, 'Unable to lookup a user by username or email address');
            return callback({'code': 500, 'msg': 'Unable to lookup a user by username or email address'});
        }

        return callback(null, user);
    });
};*/
